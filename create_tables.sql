-- CREATE EXTENSION IF NOT EXISTS "uuid-ossp"; -- For generating UUIDs in Postgres if not done by app
-- CREATE EXTENSION IF NOT EXISTS "pgcrypto"; -- For cryptographic functions

BEGIN;

-- Table for Chat Sessions
CREATE TABLE IF NOT EXISTS chat_sessions (
    session_id UUID PRIMARY KEY,                          -- UUID generated by the application
    course_id VARCHAR(255) NOT NULL,
    user_identifier TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    last_activity_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,                               -- Timestamp when the session expires (NULL if no expiration)
    request_limit INTEGER,                                -- Maximum number of requests allowed in this session (NULL if no limit)
    requests_used INTEGER NOT NULL DEFAULT 0              -- Number of requests used in this session
);

-- Indexes for chat_sessions
CREATE INDEX IF NOT EXISTS idx_chat_sessions_course_id ON chat_sessions(course_id);
CREATE INDEX IF NOT EXISTS idx_chat_sessions_user_identifier ON chat_sessions(user_identifier);
CREATE INDEX IF NOT EXISTS idx_chat_sessions_created_at ON chat_sessions(created_at);
CREATE INDEX IF NOT EXISTS idx_chat_sessions_expires_at ON chat_sessions(expires_at); -- Index for expiration query

COMMENT ON TABLE chat_sessions IS 'Stores information about individual chat sessions.';
COMMENT ON COLUMN chat_sessions.session_id IS 'Unique identifier for the chat session (PK), generated by the application.';
COMMENT ON COLUMN chat_sessions.course_id IS 'Identifier for the course this session pertains to.';
COMMENT ON COLUMN chat_sessions.user_identifier IS 'Optional identifier for the user or client session.';
COMMENT ON COLUMN chat_sessions.created_at IS 'Timestamp when the session was created.';
COMMENT ON COLUMN chat_sessions.last_activity_at IS 'Timestamp of the last interaction in this session.';
COMMENT ON COLUMN chat_sessions.expires_at IS 'Timestamp when the session is set to expire. NULL means the session does not automatically expire based on this field.';
COMMENT ON COLUMN chat_sessions.request_limit IS 'The maximum number of requests allowed for this session. NULL means no specific limit is set at the session level.';
COMMENT ON COLUMN chat_sessions.requests_used IS 'The number of requests that have been made within this session.';


-- Table for Interaction Logs
CREATE TABLE IF NOT EXISTS interaction_logs (
    interaction_id UUID PRIMARY KEY,                      -- UUID generated by the application
    session_id UUID NOT NULL REFERENCES chat_sessions(session_id) ON DELETE CASCADE,
    
    timestamp_user_request TIMESTAMPTZ DEFAULT NOW(),
    timestamp_llm1_start TIMESTAMPTZ,
    timestamp_llm1_end TIMESTAMPTZ,
    timestamp_internal_search_start TIMESTAMPTZ,
    timestamp_internal_search_end TIMESTAMPTZ,
    timestamp_llm2_start TIMESTAMPTZ,
    timestamp_llm2_end TIMESTAMPTZ,
    timestamp_final_response TIMESTAMPTZ,

    user_original_prompt TEXT NOT NULL,

    llm1_model_name VARCHAR(100),
    llm1_input_prompt TEXT,
    llm1_rephrased_question TEXT,
    llm1_keywords_extracted TEXT[],
    llm1_semantic_search_string TEXT,
    llm1_input_tokens INTEGER,
    llm1_output_tokens INTEGER,
    llm1_processing_time_ms INTEGER,

    internal_search_query_keywords TEXT[],
    internal_search_query_semantic TEXT,
    internal_search_retrieved_docs JSONB,
    internal_search_processing_time_ms INTEGER,

    llm2_model_name VARCHAR(100),
    llm2_constructed_prompt TEXT,
    llm2_final_response TEXT,
    llm2_input_tokens INTEGER,
    llm2_output_tokens INTEGER,
    llm2_processing_time_ms INTEGER,

    final_response_to_user TEXT,

    overall_status VARCHAR(50) DEFAULT 'PROCESSING',
    error_message TEXT,
    error_step VARCHAR(50)
);

-- Indexes for interaction_logs
CREATE INDEX IF NOT EXISTS idx_interaction_logs_session_id ON interaction_logs(session_id);
CREATE INDEX IF NOT EXISTS idx_interaction_logs_timestamp_user_request ON interaction_logs(timestamp_user_request);
CREATE INDEX IF NOT EXISTS idx_interaction_logs_overall_status ON interaction_logs(overall_status);
-- Optional GIN index for searching within keywords array:
-- CREATE INDEX IF NOT EXISTS idx_interaction_logs_llm1_keywords_gin ON interaction_logs USING GIN (llm1_keywords_extracted);

COMMENT ON TABLE interaction_logs IS 'Logs each step of a user query processing pipeline.';
COMMENT ON COLUMN interaction_logs.interaction_id IS 'Unique identifier for this specific interaction (PK), generated by the application.';
COMMENT ON COLUMN interaction_logs.session_id IS 'Foreign key linking to the chat_sessions table.';
COMMENT ON COLUMN interaction_logs.timestamp_user_request IS 'When the user''s prompt was received by the system.';
COMMENT ON COLUMN interaction_logs.user_original_prompt IS 'The raw prompt text from the user.';
COMMENT ON COLUMN interaction_logs.llm1_rephrased_question IS 'The question rephrased by the first LLM call.';
COMMENT ON COLUMN interaction_logs.llm1_keywords_extracted IS 'Keywords extracted by the first LLM call (for BM25).';
COMMENT ON COLUMN interaction_logs.llm1_semantic_search_string IS 'String for semantic search, from the first LLM call.';
COMMENT ON COLUMN interaction_logs.llm1_input_tokens IS 'Input token count for the first LLM call.';
COMMENT ON COLUMN interaction_logs.llm1_output_tokens IS 'Output token count for the first LLM call.';
COMMENT ON COLUMN interaction_logs.internal_search_retrieved_docs IS 'JSONB array of documents retrieved by internal search, with scores.';
COMMENT ON COLUMN interaction_logs.llm2_constructed_prompt IS 'The full prompt, including context, sent to the second LLM.';
COMMENT ON COLUMN interaction_logs.llm2_final_response IS 'The raw response from the second LLM.';
COMMENT ON COLUMN interaction_logs.llm2_input_tokens IS 'Input token count for the second LLM call.';
COMMENT ON COLUMN interaction_logs.llm2_output_tokens IS 'Output token count for the second LLM call.';
COMMENT ON COLUMN interaction_logs.final_response_to_user IS 'The final response text sent back to the user.';
COMMENT ON COLUMN interaction_logs.overall_status IS 'Overall status of processing this interaction (e.g., SUCCESS, ERROR_LLM1).';
COMMENT ON COLUMN interaction_logs.error_message IS 'Detailed error message if processing failed.';
COMMENT ON COLUMN interaction_logs.error_step IS 'Identifies the step where an error occurred.';

-- Create the users table
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL, -- Store the HASH (e.g., Argon2 output)
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Create the function to update 'updated_at' automatically
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply the trigger to the users table
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_users' AND tgrelid = 'users'::regclass) THEN
        CREATE TRIGGER set_timestamp_users
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE PROCEDURE trigger_set_timestamp();
    END IF;
END $$;


-- Create the active_sessions table (for user authentication sessions, distinct from chat_sessions)
CREATE TABLE IF NOT EXISTS active_sessions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_signature VARCHAR(255) NOT NULL UNIQUE, -- Store part of the JWT (e.g., signature)
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for better performance on active_sessions
CREATE INDEX IF NOT EXISTS idx_active_sessions_user_id ON active_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_active_sessions_expires_at ON active_sessions(expires_at);

-- Grant necessary permissions on tables/sequences to the user (replace 'chatbot_admin' with your actual DB user/role)
-- Note: Sequences for UUID PKs are not typically granted this way as UUIDs are app-generated or use extensions.
-- Grants for SERIAL PK sequences:
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_class WHERE relname = 'users_id_seq') THEN
        GRANT USAGE, SELECT ON SEQUENCE users_id_seq TO chatbot_admin;
    END IF;
    IF EXISTS (SELECT 1 FROM pg_class WHERE relname = 'active_sessions_id_seq') THEN
        GRANT USAGE, SELECT ON SEQUENCE active_sessions_id_seq TO chatbot_admin;
    END IF;
END $$;

-- Grants for tables:
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE chat_sessions TO chatbot_admin;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE interaction_logs TO chatbot_admin;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE users TO chatbot_admin;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE active_sessions TO chatbot_admin;

COMMIT;